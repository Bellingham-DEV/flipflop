FlipFlop &mdash; flipflop your features
========================

[![Build Status](https://travis-ci.org/pda/flipflop.png)](https://travis-ci.org/pda/flipflop)

**FlipFlop** provides a declarative, layered way of enabling and disabling application functionality at run-time.

This gem optimizes for:

* developer ease-of-use,
* visibility and control for other stakeholders (like marketing); and
* run-time performance

There are three layers of strategies per feature:

* default
* database, to flipflop features site-wide for all users
* cookie, to flipflop features just for you (or someone else)

There is also a configurable system-wide default - !Rails.env.production?` works nicely.

FlipFlop has a dashboard UI that's easy to understand and use.

![Feature FlipFlopper Dashboard](https://cloud.githubusercontent.com/assets/828243/4934741/a5773568-65a4-11e4-98d8-5e9a32720b2e.png)

Install
-------

**Rails 3.0, 3.1 and 3.2+**

    # Gemfile
    gem "flipflop"

    # Generate the model and migration
    > rails g flipflop:install

    # Run the migration
    > rake db:migrate

    # Include the Feature model, e.g. config/initializers/feature.rb:
    require 'feature'

Declaring Features
------------------

```ruby
# This is the model class generated by rails g flipflop:install
class Feature < ActiveRecord::Base
  include FlipFlop::Declarable

  # The recommended FlipFlop strategy stack.
  strategy FlipFlop::CookieStrategy
  strategy FlipFlop::DatabaseStrategy
  strategy FlipFlop::DefaultStrategy
  default false

  # A basic feature declaration.
  feature :shiny_things

  # Override the system-wide default.
  feature :world_domination, default: true

  # Enabled half the time..? Sure, we can do that.
  feature :flakey,
    default: proc { rand(2).zero? }

  # Provide a description, normally derived from the feature name.
  feature :something,
    default: true,
    description: "Ability to purchase enrollments in courses"

end
```


Checking Features
-----------------

`FlipFlop.on?` or the dynamic predicate methods are used to check feature state:

```ruby
FlipFlop.on? :world_domination   # true
FlipFlop.world_domination?       # true

FlipFlop.on? :shiny_things       # false
FlipFlop.shiny_things?           # false
```

Views and controllers use the `feature?(key)` method:

```erb
<div>
  <% if feature? :world_domination %>
    <%= link_to "Dominate World", world_dominations_path %>
  <% end %>
</div>
```


Feature FlipFlopping Controllers
--------------------------------

The `FlipFlop::ControllerFilters` module is mixed into the base `ApplicationController` class.  The following controller will respond with 404 Page Not Found to all but the `index` action unless the `:something` feature is enabled:

```ruby
class SampleController < ApplicationController

  require_feature :something, :except => :index

  def show
  end

  def index
  end

end
```

Dashboard
---------

The dashboard provides visibility and control over the features.

The gem includes some basic styles:

```haml
= content_for :stylesheets_head do
  = stylesheet_link_tag "flipflop"
```

You probably don't want the dashboard to be public.  Here's one way of implementing access control.

app/controllers/admin/features_controller.rb:

```ruby
class Admin::FeaturesController < FlipFlop::FeaturesController
  before_filter :assert_authenticated_as_admin
end
```

app/controllers/admin/strategies_controller.rb:

```ruby
class Admin::StrategiesController < FlipFlop::StrategiesController
  before_filter :assert_authenticated_as_admin
end
```

routes.rb:

```ruby
namespace :admin do
  resources :features, only: [ :index ] do
    resources :strategies, only: [ :update, :destroy ]
  end
end

mount FlipFlop::Engine => "/admin/features"
```

Cacheable
---------

You can optimize your feature to ensure that it doesn't make a ton of feature
calls by adding Cacheable to your model.
```ruby
extend FlipFlop::Cacheable
```

This will ensure that your features are eager loaded with one call to the
database instead of every call to FlipFlop#on? generating a call to the
database. This is helpful if you have a larger Rails application and more than
a few features defined.

To start or reset the cache, just call #start_feature_cache.


----
Originally created by Paul Annesley
Copyright © 2011-2013 Learnable Pty Ltd
Copyright © 2016 Voormedia

Licensed with [MIT Licence](http://www.opensource.org/licenses/mit-license.php)
